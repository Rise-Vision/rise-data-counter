<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">

    <title>rise-data-counter test</title>

    <script src="../../node_modules/@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../node_modules/@polymer/test-fixture/test-fixture.js"></script>
    <script src="../../node_modules/mocha/mocha.js"></script>
    <script src="../../node_modules/chai/chai.js"></script>
    <script src="../../node_modules/wct-mocha/wct-mocha.js"></script>
    <script src="../../node_modules/sinon/pkg/sinon.js"></script>
    <script src="../../node_modules/moment/moment.js"></script>

    <script type="text/javascript">
      RisePlayerConfiguration = {
        isConfigured: () => true
      };
    </script>

    <script type="module" src="../../src/rise-data-counter.js"></script>
  </head>
  <body>
    <test-fixture id="test-block">
      <template>
        <rise-data-counter></rise-data-counter>
      </template>
    </test-fixture>

    <script type="module">
      suite("rise-data-counter", () => {
        let sandbox = sinon.createSandbox();
        let element, clock, riseElement;

        setup(() => {
          RisePlayerConfiguration.Logger = {
            info: () => {},
            warning: () => {},
            error: sinon.spy()
          };

          RisePlayerConfiguration.isPreview = () => {
            return false;
          };

          clock = sinon.useFakeTimers();

          element = fixture("test-block");

          riseElement = element.__proto__.__proto__;

          sandbox.spy(riseElement, '_sendEvent');
          sandbox.stub(riseElement, '_setUptimeError');
        });

        teardown(()=>{
          sandbox.restore();
          clock.restore();
        });

        suite("properties", () => {
          test("should set default for type", () => {
            assert.equal(element.type, "down");
          });
        });

        suite("ready", () => {
          let stub;

          setup(() => {
            stub = sandbox.stub(window, "addEventListener");
          });

          test("should listen for rise-components-ready and call init", () => {
            RisePlayerConfiguration.isConfigured = () => false;
            element.ready();

            assert.isTrue(stub.calledWith('rise-components-ready'));
          });

          test("should call _init() if RisePlayerConfiguration is configured", () => {
            RisePlayerConfiguration.isConfigured = () => true;
            sandbox.stub(element, '_init');

            element.ready();

            assert.isTrue(element._init.calledOnce);
            assert.isFalse(stub.calledOnce);
          });

          test("should setup handlers for viewer events", () => {
            sandbox.stub(element, "_reset");
            sandbox.stub(element, "_stop");

            element.dispatchEvent( new CustomEvent( "rise-presentation-play" ));
            element.dispatchEvent( new CustomEvent( "rise-presentation-stop" ));

            assert.isTrue(element._reset.calledOnce);
            assert.isTrue(element._stop.calledOnce);
          });

        });

        suite( "_isValidType", () => {

          test( "should return true if 'type' attribute is 'down'", () => {
            assert.isTrue( element._isValidType( "down" ) );
          } );

          test( "should return true if 'type' attribute is 'up'", () => {
            assert.isTrue( element._isValidType( "up" ) );
          } );

          test( "should return false when invalid", () => {
            assert.isFalse( element._isValidType( "test" ) );
          } );

        } );

        suite( "_isValidDate", () => {

          test( "should return true if 'date' has correct strict format YYYY-MM-DD", () => {
            assert.isTrue( element._isValidDate( "2019-10-29" ) );
          } );

          test( "should return false if 'date' has incorrect strict format", () => {
            assert.isFalse( element._isValidDate( "2019-29-10" ) );
            assert.isFalse( element._isValidDate( "29-10-2019" ) );
            assert.isFalse( element._isValidDate( "2019-10-29T15:18:06.960Z" ) );
          } );

        } );

        suite( "_isValidTime", () => {

          test( "should return true if 'time' has correct strict format HH:mm", () => {
            assert.isTrue( element._isValidTime( "16:20" ) );
          } );

          test( "should return false if 'time' has incorrect strict format", () => {
            assert.isFalse( element._isValidTime( "16-20" ) );
            assert.isFalse( element._isValidTime( "16.20" ) );
            assert.isFalse( element._isValidDate( "16:20:06" ) );
            assert.isFalse( element._isValidDate( "2019-10-29T15:18:06.960Z" ) );
          } );

        } );

        suite( "_hasValidFormat", () => {

          test( "should return false if no 'date' or 'time' value", () => {
            assert.isFalse( element._hasValidFormat() );
          } );

          test( "should return false if 'date' configured with invalid format", () => {
            element.date = "test";
            assert.isFalse( element._hasValidFormat() );
          } );

          test( "should return false if 'time' configured with invalid format", () => {
            element.time = "test";
            assert.isFalse( element._hasValidFormat() );
          } );

          test( "should return true if 'date' configured with valid format", () => {
            element.date = "2019-10-29";
            assert.isTrue( element._hasValidFormat() );
          } );

          test( "should return true if 'time' configured with valid format", () => {
            element.time = "16:20";
            assert.isTrue( element._hasValidFormat() );
          } );

        } );

        suite( "_sendCounterEvent", () => {
          test( "should process 'data-error' event and set uptime correctly", () => {
            element._sendCounterEvent( 'data-error', 'test' );

            assert.isTrue( riseElement._sendEvent.calledWith( 'data-error', 'test' ) );
            assert.isTrue( riseElement._setUptimeError.calledWith( true ) );
          } );

          test( "should process 'data-update' event and set uptime correctly", () => {
            element._sendCounterEvent( 'data-update', 'test' );

            assert.isTrue( riseElement._sendEvent.calledWith( 'data-update', 'test' ) );
            assert.isTrue( riseElement._setUptimeError.calledWith( false ) );
          } );

        } );

        suite( "_runTimer", () => {
          test( "should call '_processCount()' after 1 second", () => {
            sandbox.stub( element, "_processCount" );

            element._runTimer( 1 );

            assert.isFalse( element._processCount.calledOnce );

            clock.tick( 1000 );

            assert.isTrue( element._processCount.calledOnce );
          } );

          test( "should call '_processCount()' after 1 minute", () => {
            sandbox.stub( element, "_processCount" );

            element._runTimer( 60 );

            clock.tick( 30000 );

            assert.isFalse( element._processCount.calledOnce );

            clock.tick( 30000 );

            assert.isTrue( element._processCount.calledOnce );
          } );
        } );

        suite( "_reset", () => {
          setup( () => {
            sandbox.stub( element, "_stop" );
            sandbox.stub( element, "_start" );
          } );

          test( "should not execute reset when an initial start still pending", () => {
            element._reset();

            assert.isFalse( element._stop.calledOnce );
            assert.isFalse( element._start.calledOnce );
          } );

          test( "should execute reset when not the initial start", () => {
            element._initialStart = false;
            element._reset();

            assert.isTrue( element._stop.calledOnce );
            assert.isTrue( element._start.calledOnce );
          } );
        } );

        suite( "_start", () => {
          setup( () => {
            sandbox.stub( element, "_runTimer" );
            sandbox.stub( element, "_initializeDateDuration" );
          } );

          test( "should call _runTimer() when type and date or time formats are valid", () => {
            element.type = "down";
            element.date = "2019-10-29";
            element._start();

            assert.isTrue( element._runTimer.calledOnce );
          } );

          test( "should call _initializeDateDuration() when configured for valid date", () => {
            element.type = "down";
            element.date = "2019-10-29";
            element._start();

            assert.isTrue( element._initializeDateDuration.calledWith( element.date ) );
          } );

          test( "should not call _runTimer() when type is invalid", () => {
            element.type = "test";
            element.date = "2019-10-29";
            element._start();

            assert.isFalse( element._runTimer.calledOnce );
          } );

          test( "should not call _runTimer() when empty date or time values", () => {
            element.type = "date";
            element._start();

            assert.isFalse( element._runTimer.calledOnce );
          } );
        } );

        suite( "_stop", () => {
          setup( () => {
            sandbox.stub( element, "_processCount" );
          } );

          test( "should cancel the timer", () => {
            element.type = "down";
            element.date = "2019-10-29";
            element.refresh = 60;
            element._start();

            clock.tick(30000);

            assert.isTrue( element._refreshDebounceJob.isActive() );
            assert.isNotNull( element._dateDuration );

            element._stop();

            clock.tick(30000);

            assert.isFalse( element._processCount.called );
            assert.isFalse( element._refreshDebounceJob.isActive() );
            assert.isNull( element._dateDuration );
          } );

        } );

        suite( "_handleStart", () => {

          setup( () => {
            sandbox.stub( element, "_start" );
          } );

          test( "should call _start() when this is the initial 'start'", () => {
            const event = new CustomEvent( "start" );
            element.dispatchEvent( event );

            assert.isTrue( element._start.calledOnce );
            assert.isFalse( element._initialStart, "_initialStart set to false" );
          } );

          test( "should not call _start() when this is not the initial start", () => {
            element._initialStart = false;

            const event = new CustomEvent( "start" );
            element.dispatchEvent( event );

            assert.isFalse( element._start.called );
          } );

        } );

        suite( "_initializeDateDuration", () => {
          test( "should initialize correct duration with given target date based on 'down' type", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "down" );

            assert.equal( element._dateDuration.asMilliseconds(), 2419200000 );
            assert.equal( element._dateDuration.asDays(), 28 );

            // test a date that is same as target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-29", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "down" );

            assert.equal( element._dateDuration.asMilliseconds(), 0 );
            assert.equal( element._dateDuration.asDays(), 0 );

            // test a date that has passed target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-11-01", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "down" );

            assert.equal( element._dateDuration.asMilliseconds(), -259200000 );
            assert.equal( element._dateDuration.asDays(), -3 );

          } );

          test( "should initialize correct duration with given target date based on 'up' type", () => {
            // test a date that is after target date to start from
            clock = sinon.useFakeTimers({now: moment("2019-10-29", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-01", "up" );

            assert.equal( element._dateDuration.asMilliseconds(), 2419200000 );
            assert.equal( element._dateDuration.asDays(), 28 );

            // test a date that is same as target date to start from
            clock = sinon.useFakeTimers({now: moment("2019-10-29", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "up" );

            assert.equal( element._dateDuration.asMilliseconds(), 0 );
            assert.equal( element._dateDuration.asDays(), 0 );

            // test a date that is before target date to start from
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "up" );

            assert.equal( element._dateDuration.asMilliseconds(), -2419200000 );
            assert.equal( element._dateDuration.asDays(), -28 );

          } );
        } );

        suite( "_updateDateDuration", () => {
          test( "should update correct duration with given interval (MS) and based on 'down' type", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "down" );

            assert.equal( element._dateDuration.days(), 28 );

            // simulate a 24 hour interval
            element._updateDateDuration( 24 * 60 * 60 * 1000, "down" );

            assert.equal( element._dateDuration.days(), 27 );

            // simulate a 10 second interval
            element._updateDateDuration( 10 * 1000, "down" );

            assert.equal( element._dateDuration.seconds(), 50 );

            element._updateDateDuration( 10 * 1000, "down" );

            assert.equal( element._dateDuration.seconds(), 40 );
          } );

          test( "should update correct duration with given interval (MS) and based on 'up' type", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-29", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-01", "up" );

            assert.equal( element._dateDuration.days(), 28 );

            // simulate a 24 hour interval
            element._updateDateDuration( 24 * 60 * 60 * 1000, "up" );

            assert.equal( element._dateDuration.days(), 29 );

            // simulate a 10 second interval
            element._updateDateDuration( 10 * 1000, "up" );

            assert.equal( element._dateDuration.seconds(), 10 );

            element._updateDateDuration( 10 * 1000, "up" );

            assert.equal( element._dateDuration.seconds(), 20 );
          } );
        } );

        suite( "_getDateDurationFormatted", () => {
          test( "should return object with all correct properties and values", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "down" );

            // simulate a 10 second interval
            element._updateDateDuration( 10 * 1000, "down" );

            const formatted = element._getDateDurationFormatted();

            assert.deepEqual( formatted, {
              days: 27,
              hours: 23,
              milliseconds: 0,
              minutes: 59,
              months: 0,
              seconds: 50,
              weeks: 3,
              years: 0
            } )
          } );
        } );

        suite( "_getDateDifferenceFormatted", () => {
          test( "should return object with all correct properties and values based on 'down' type", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-29", "down" );

            // simulate a 10 second interval
            element._updateDateDuration( 10 * 1000, "down" );

            const formatted = element._getDateDifferenceFormatted( "2019-10-29", "down" );

            assert.deepEqual( formatted, {
              days: 28,
              hours: 672,
              milliseconds: 2419200000,
              minutes: 40320,
              months: 0,
              seconds: 2419200,
              weeks: 4,
              years: 0
            } )
          } );

          test( "should return object with all correct properties and values based on 'up' type", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-29", "YYYY-MM-DD").valueOf()});

            element._initializeDateDuration( "2019-10-01", "up" );

            // simulate a 10 second interval
            element._updateDateDuration( 10 * 1000, "up" );

            const formatted = element._getDateDifferenceFormatted( "2019-10-01", "up" );

            assert.deepEqual( formatted, {
              days: 28,
              hours: 672,
              milliseconds: 2419200000,
              minutes: 40320,
              months: 0,
              seconds: 2419200,
              weeks: 4,
              years: 0
            } )
          } );
        } );

        suite( "_getDateData", () => {
          test( "should return object with all correct properties and values", () => {
            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element.date = "2019-10-29";
            element.type = "down";
            element.refresh = 10;

            element._start();

            const data = element._getDateData();

            assert.deepEqual( data, {
              targetDate: "2019-10-29",
              type: "count down",
              duration: {
                days: 27,
                hours: 23,
                milliseconds: 0,
                minutes: 59,
                months: 0,
                seconds: 50,
                weeks: 3,
                years: 0
              },
              difference: {
                days: 28,
                hours: 672,
                milliseconds: 2419200000,
                minutes: 40320,
                months: 0,
                seconds: 2419200,
                weeks: 4,
                years: 0
              }
            });
          } );

        } );

        suite( "_processCount", () => {
          test( "should send 'data-update' event and run timer", () => {
            sandbox.stub(element, "_sendCounterEvent");
            sandbox.stub(element, "_runTimer");

            // test a date that is before target date to count down to
            clock = sinon.useFakeTimers({now: moment("2019-10-01", "YYYY-MM-DD").valueOf()});

            element.date = "2019-10-29";
            element.type = "down";
            element.refresh = 10;

            element._start();
            element._processCount();

            assert.isTrue( element._sendCounterEvent.calledWith( 'data-update', {
              date: {
                targetDate: "2019-10-29",
                type: "count down",
                duration: {
                  days: 27,
                  hours: 23,
                  milliseconds: 0,
                  minutes: 59,
                  months: 0,
                  seconds: 50,
                  weeks: 3,
                  years: 0
                },
                difference: {
                  days: 28,
                  hours: 672,
                  milliseconds: 2419200000,
                  minutes: 40320,
                  months: 0,
                  seconds: 2419200,
                  weeks: 4,
                  years: 0
                }
              },
              time: null
            } ) );

            assert.isTrue( element._runTimer.calledWith( 10 ) );

          } );
        } );

      });
    </script>
  </body>
</html>
